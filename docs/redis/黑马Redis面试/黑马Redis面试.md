黑马Redis面试

## Redis 面试框架

![image-20250829174159581](https://typora-yuanbaoer2.oss-cn-shanghai.aliyuncs.com/img-typora/image-20250829174159581.png)

## 高频面试问题

**使用场景**

> - Redis的数据持久化策略有哪些
> - 什么是缓存穿透，怎么解决
> - 什么是布隆过滤器
> - 什么是缓存击穿，怎么解决
> - 什么是缓存雪崩，怎么解决
> - redis双写问题
> - Redis分布式锁如何实现
> - Redis实现分布式锁如何合理的控制锁的有效时长
> - Redis的数据过期策略有哪些
> - Redis的数据淘汰策略有哪些

**其他面试题**

> - Redis集群有哪些方案，知道嘛
> - 什么是Redis主从同步
> - 你们使用Redis是单点还是集群？哪种集群
> - Redis分片集群中数据是怎么存储和读取的
> - Redis集群脑裂
> - 怎么保证redis1的高并发高可用
> - 你们用过redis的事务吗？事务的命令有哪些
> - redis是单线程的，但是为什么还是那么快？

---

### 实际面试案例一

1. **我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？**

> 结合项目回答
>
> - 一是验证你的项目场景的真实性，二是为了作为深入发问的切入点
>
> - 缓存
>
>   追问：
>
>   - **缓存三兄弟（穿透、击穿、雪崩）、双写一致、持久化、数据过期策略、数据淘汰策略**
>
> - 分布式锁
>
>   追问：分布式锁如何实现
>
>   - **setnx、redission**
>
> - 消息队列、延迟队列
>
>   追问：**何种数据类型**
>
> - ... 

2. **如果发生了缓存穿透、击穿、雪崩，该如何解决呢？**

> 这里就一次性问了三个问题，需要依次回答
>
> - **缓存穿透**：查询一个 **不存在** 的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库
>
>   - **解决方案一：**缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存。
>
>     ```json
>     {key:1, value: null}
>     ```
>
>     **优点：简单**
>
>     **缺点：消耗内存，可能会发生不一致问题**
>
>   - **解决方案二：布隆过滤器**
>
>     ![image-20250829180247890](https://typora-yuanbaoer2.oss-cn-shanghai.aliyuncs.com/img-typora/image-20250829180247890.png)
>
>   - **布隆过滤器概念**
>
>     ![image-20250829180449000](https://typora-yuanbaoer2.oss-cn-shanghai.aliyuncs.com/img-typora/image-20250829180449000.png)
>
>     可能会产生**误判**
>
>     ![image-20250829180721946](https://typora-yuanbaoer2.oss-cn-shanghai.aliyuncs.com/img-typora/image-20250829180721946.png)
>
>     可以通过实现方案调整误判率
>
>   

---

<<<<<<< Updated upstream
=======


## 1、Redis 每种数据的使用场景

1. **String（字符串）**
   - 适用场景：
     - 存储简单的键值对数据，如用户昵称、头像 URL 等
     - 计数器（通过`INCR`/`DECR`操作），如文章阅读量、点赞数
     - 分布式锁的实现（利用`SETNX`命令）
     - 存储 JSON 格式的字符串，实现简单的对象缓存
   - 特点：二进制安全，可存储任何数据（文本、图片二进制等），最大 512MB
2. **Hash（哈希）**
   - 适用场景：
     - 存储对象类型的数据，如用户信息（姓名、年龄、邮箱等）
     - 商品属性信息（价格、库存、规格等）
     - 配置信息存储
   - 特点：键值对集合，适合存储结构化数据，可单独对字段进行操作，节省内存
3. **List（列表）**
   - 适用场景：
     - 消息队列（利用`LPUSH`和`RPOP`实现）
     - 最新消息排行（如朋友圈、微博时间线）
     - 分页查询（利用`LRANGE`命令）
     - 栈（`LPUSH`+`LPOP`）或队列（`LPUSH`+`RPOP`）实现
   - 特点：有序可重复，底层是双向链表，两端操作效率高
4. **Set（集合）**
   - 适用场景：
     - 标签系统（如文章标签、用户兴趣标签）
     - 好友关系（共同好友、好友推荐）
     - 去重操作（如 UV 统计）
     - 抽奖系统（`SRANDMEMBER`随机获取元素）
   - 特点：无序不可重复，支持交集、并集、差集等集合运算
5. **Sorted Set（有序集合）**
   - 适用场景：
     - 排行榜（如游戏积分、销量排名）
     - 带权重的消息队列
     - 范围查询（如获取成绩前 10 名的学生）
     - 延时任务（结合时间戳作为 score）
   - 特点：有序且不可重复，每个元素关联一个分数 (score)，可按分数排序
6. **Bitmap（位图）**
   - 适用场景：
     - 签到系统（每天用 1 位表示是否签到）
     - 用户在线状态（1 表示在线，0 表示离线）
     - 活跃用户统计
   - 特点：节省空间，适合处理海量的二进制状态数据
7. **HyperLogLog**
   - 适用场景：
     - 独立访客 (UV) 统计
     - 搜索记录去重计数
     - 各种去重计数场景
   - 特点：占用空间极小（约 12KB），适合超大数据量的基数估算，有一定误差率
8. **Geospatial（地理空间）**
   - 适用场景：
     - 附近的人 / 地点（如外卖配送范围、附近商家）
     - 地理位置距离计算
     - 地理围栏
   - 特点：存储经纬度信息，支持距离计算和范围查询
9. **Stream（流）**
   - 适用场景：
     - 消息队列（支持持久化、消费确认、分组消费）
     - 日志收集
     - 事件溯源
   - 特点：Redis 5.0 新增，专为消息处理设计，支持复杂的消息传递模式

---

## 2、缓存穿透、击穿、雪崩、预热、降级

| 概念         | 核心含义                                                     | 发生原因                                                    | 解决思路                                                     |
| ------------ | ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------------------------------------------ |
| **缓存雪崩** | 大量缓存同时失效，请求全打到数据库，导致数据库压力骤增甚至宕机 | 1. 缓存 key 设置了相同的过期时间 2. Redis 宕机              | 1. 过期时间加随机值避免同时失效 2. 多级缓存（本地缓存 + Redis） 3. Redis 高可用（主从、哨兵、集群） 4. 熔断 / 限流保护数据库 |
| **缓存穿透** | 查询一个不存在的数据，缓存和数据库都没有，每次请求都穿透到数据库 | 1. 恶意攻击查询不存在的 key 2. 业务逻辑允许查询不存在的数据 | 1. 布隆过滤器提前拦截不存在的 key 2. 查询结果为空也缓存（设置较短过期时间） 3. 接口层做参数校验 |
| **缓存击穿** | 一个热点 key 过期瞬间，大量请求同时访问该 key，都打到数据库  | 热点 key 过期，同时有大量并发请求                           | 1. 互斥锁（缓存失效时，一个请求去数据库查，其他请求等待（直到缓存被重建）） 2. 热点 key 永不过期或后台定时更新 3. 热点数据提前预热 |
| **缓存预热** | 系统启动或低峰期提前将热点数据加载到缓存，避免首次访问时缓存缺失 | 1. 系统重启后缓存为空 2. 大促前热点数据未提前加载           | 1. 写脚本批量加载热点数据 2. 订阅数据库 binlog 异步更新缓存 3. 系统启动时主动加载 |
| **缓存降级** | 在缓存或数据库压力过大时，主动降低缓存功能，保证核心业务可用 | 1. Redis 性能下降或不可用 2. 数据库负载过高                 | 1. 返回默认值或旧数据 2. 关闭非核心功能的缓存查询 3. 限流 + 排队机制 |

**解决方法**

| 问题类型     | 核心解决思路                          | 具体实现方法                                                 | 适用场景                                   |
| ------------ | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| **缓存雪崩** | 避免缓存同时失效 + 增强系统抗风险能力 | 1. **过期时间随机化**（如基础时间 + 5~10 分钟随机值） 2. **实现多级缓存**（本地缓存 Caffeine + 分布式缓存 Redis） 3. **Redis 集群高可用**（主从复制 + 哨兵模式，至少 3 主 3 从） 4. **数据库限流**（使用 Sentinel 或 Hystrix 限制并发量） 5. **缓存降级开关**（极端情况直接返回兜底数据） | 电商大促、热点活动等流量集中场景           |
| **缓存穿透** | 拦截无效请求 + 缓存空结果             | 1. **布隆过滤器**（预存所有可能存在的 key，拦截不存在的请求） 2. **空值缓存**（查询结果为空时，缓存空值并设置短期过期时间） 3. **接口层校验**（过滤非法参数，如 ID<=0 的请求） 4. **限流防护**（对同一 IP 的高频异常请求进行限流） | 恶意攻击、业务上允许查询不存在数据的场景   |
| **缓存击穿** | 保护热点 key 的缓存有效性             | 1. 互斥锁（Redis 的 SETNX 命令，只有一个线程更新缓存，其他线程等待） 2. 热点 key 永不过期（业务层控制更新，不设置过期时间） 3. 定时任务预热（后台线程提前更新即将过期的热点数据） 4. 分布式锁（Redisson 实现，保证缓存更新的原子性） | 秒杀商品、热门文章等单一热点数据场景       |
| **缓存预热** | 主动加载热点数据到缓存                | 1. 启动加载（系统启动时执行脚本，批量查询热点数据写入缓存） 2. 定时任务（低峰期定时刷新热点数据，如凌晨 3 点执行） 3. 流量触发预热（首次访问时异步加载关联热点数据） 4. 数据库 binlog 同步（通过 Canal 监听 binlog，实时同步更新缓存） | 系统重启后、大促活动前、新功能上线时       |
| **缓存降级** | 牺牲非核心功能保障核心流程            | 1. 静态化降级（返回本地静态文件，如商品详情页静态化） 2. 功能降级（关闭推荐、评价等非核心模块的缓存查询） 3. 数据降级（返回旧版本数据或默认值，如库存显示 “充足”） 4. 限流降级（超出阈值后排队等待，或直接返回降级提示） | Redis 集群故障、数据库压力过高、流量突增时 |



## 3、Redis 主从复制

**全量复制、增量复制**

**Redis 主从同步的真实机制**：

1. **全量同步**：
   - 主节点执行 `bgsave` 生成 RDB 文件
   - 将 RDB 文件发送给从节点
   - 从节点清空本地数据，加载 RDB 文件
   - 同时，主节点将 RDB 生成期间的写命令存入**内存缓冲区**（不是日志文件）
   - RDB 发送完成后，主节点再把缓冲区中的命令发送给从节点
2. **增量同步**：
   - 基于**复制偏移量**和**复制积压缓冲区**（内存环形缓冲区）
   - 从节点发送自己的偏移量，主节点只发送从该位置起的增量命令（偏移量如果超出复制积压缓冲区就要重新执行`全量同步`）
   - 不依赖磁盘日志文件，而是直接内存到内存的命令传输

---

Redis 的主从同步是**热更新**的。

在主从复制过程中：

- **主节点**在同步数据给从节点的同时，**依然可以正常处理读写请求**，不会中断服务
- **从节点**在接收和加载 RDB 文件阶段会短暂阻塞（不能处理客户端读请求），但加载完成后会持续从主节点同步增量数据
- 增量同步阶段，从节点可以在**几乎不中断服务**的情况下持续更新数据

简单来说：

- 主节点全程不中断服务（真正热更新）
- 从节点只有在初始全量同步的 RDB 加载阶段会短暂不可读，之后保持热更新状态

### 什么时候全量复制、增量复制

**全量同步之后，正常情况下所有后续同步都是增量同步**。

全量同步只在以下初始情况下发生：

- 从节点第一次连接主节点
- 从节点断线后偏移量不在主节点的复制积压缓冲区范围内

在这些情况之后，主从之间就会进入稳定的增量同步模式：

- 主节点将写命令同步发送给从节点
- 同时维护复制偏移量确保数据一致性
- 只有在网络中断或积压缓冲区溢出时才可能再次触发全量同步

---

### 增量复制的工作方式

Redis 主从增量同步的实际机制是**批量 + 异步**的：

**增量同步的工作方式**：

- 主节点每执行一个写命令，会同时做两件事：
  1. 写入自己的**复制积压缓冲区**（内存环形缓冲区）
  2. 异步地发送给已连接的从节点
- 发送不是单条命令逐个发送，而是**批量打包发送**，减少网络开销
- 网络传输是异步的，主节点不会等待从节点确认就继续处理下一个命令

**影响发送频率的因素**：

- 网络 I/O 缓冲区大小
- 命令执行频率
- 系统的 TCP 传输特性（Nagle 算法等）

**数据一致性保障**：

- 每个命令都有偏移量记录
- 从节点定期向主节点报告自己的偏移量
- 主节点根据偏移量确保从节点最终拿到所有命令

**特殊情况**：

- 如果从节点断线后重连，只要它的偏移量还在主节点的复制积压缓冲区范围内，就只需补传缺失的命令
>>>>>>> Stashed changes
