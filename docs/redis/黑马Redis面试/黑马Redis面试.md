黑马Redis面试

## Redis 面试框架

![image-20250829174159581](https://typora-yuanbaoer2.oss-cn-shanghai.aliyuncs.com/img-typora/image-20250829174159581.png)

## 高频面试问题

**使用场景**

> - Redis的数据持久化策略有哪些
> - 什么是缓存穿透，怎么解决
> - 什么是布隆过滤器
> - 什么是缓存击穿，怎么解决
> - 什么是缓存雪崩，怎么解决
> - redis双写问题
> - Redis分布式锁如何实现
> - Redis实现分布式锁如何合理的控制锁的有效时长
> - Redis的数据过期策略有哪些
> - Redis的数据淘汰策略有哪些

**其他面试题**

> - Redis集群有哪些方案，知道嘛
> - 什么是Redis主从同步
> - 你们使用Redis是单点还是集群？哪种集群
> - Redis分片集群中数据是怎么存储和读取的
> - Redis集群脑裂
> - 怎么保证redis1的高并发高可用
> - 你们用过redis的事务吗？事务的命令有哪些
> - redis是单线程的，但是为什么还是那么快？

---

### 实际面试案例一

1. **我看你做的项目中，都用到了redis，你在最近的项目中哪些场景使用了redis呢？**

> 结合项目回答
>
> - 一是验证你的项目场景的真实性，二是为了作为深入发问的切入点
>
> - 缓存
>
>   追问：
>
>   - **缓存三兄弟（穿透、击穿、雪崩）、双写一致、持久化、数据过期策略、数据淘汰策略**
>
> - 分布式锁
>
>   追问：分布式锁如何实现
>
>   - **setnx、redission**
>
> - 消息队列、延迟队列
>
>   追问：**何种数据类型**
>
> - ... 

2. **如果发生了缓存穿透、击穿、雪崩，该如何解决呢？**

> 这里就一次性问了三个问题，需要依次回答
>
> - **缓存穿透**：查询一个 **不存在** 的数据，mysql查询不到数据也不会直接写入缓存，就会导致每次请求都查数据库
>
>   - **解决方案一：**缓存空数据，查询返回的数据为空，仍把这个空结果进行缓存。
>
>     ```json
>     {key:1, value: null}
>     ```
>
>     **优点：简单**
>
>     **缺点：消耗内存，可能会发生不一致问题**
>
>   - **解决方案二：布隆过滤器**
>
>     ![image-20250829180247890](https://typora-yuanbaoer2.oss-cn-shanghai.aliyuncs.com/img-typora/image-20250829180247890.png)
>
>   - **布隆过滤器概念**
>
>     ![image-20250829180449000](https://typora-yuanbaoer2.oss-cn-shanghai.aliyuncs.com/img-typora/image-20250829180449000.png)
>
>     可能会产生**误判**
>
>     ![image-20250829180721946](https://typora-yuanbaoer2.oss-cn-shanghai.aliyuncs.com/img-typora/image-20250829180721946.png)
>
>     可以通过实现方案调整误判率
>
>   

---



## 1、Redis 每种数据的使用场景

1. **String（字符串）**
   - 适用场景：
     - 存储简单的键值对数据，如用户昵称、头像 URL 等
     - 计数器（通过`INCR`/`DECR`操作），如文章阅读量、点赞数
     - 分布式锁的实现（利用`SETNX`命令）
     - 存储 JSON 格式的字符串，实现简单的对象缓存
   - 特点：二进制安全，可存储任何数据（文本、图片二进制等），最大 512MB
2. **Hash（哈希）**
   - 适用场景：
     - 存储对象类型的数据，如用户信息（姓名、年龄、邮箱等）
     - 商品属性信息（价格、库存、规格等）
     - 配置信息存储
   - 特点：键值对集合，适合存储结构化数据，可单独对字段进行操作，节省内存
3. **List（列表）**
   - 适用场景：
     - 消息队列（利用`LPUSH`和`RPOP`实现）
     - 最新消息排行（如朋友圈、微博时间线）
     - 分页查询（利用`LRANGE`命令）
     - 栈（`LPUSH`+`LPOP`）或队列（`LPUSH`+`RPOP`）实现
   - 特点：有序可重复，底层是双向链表，两端操作效率高
4. **Set（集合）**
   - 适用场景：
     - 标签系统（如文章标签、用户兴趣标签）
     - 好友关系（共同好友、好友推荐）
     - 去重操作（如 UV 统计）
     - 抽奖系统（`SRANDMEMBER`随机获取元素）
   - 特点：无序不可重复，支持交集、并集、差集等集合运算
5. **Sorted Set（有序集合）**
   - 适用场景：
     - 排行榜（如游戏积分、销量排名）
     - 带权重的消息队列
     - 范围查询（如获取成绩前 10 名的学生）
     - 延时任务（结合时间戳作为 score）
   - 特点：有序且不可重复，每个元素关联一个分数 (score)，可按分数排序
6. **Bitmap（位图）**
   - 适用场景：
     - 签到系统（每天用 1 位表示是否签到）
     - 用户在线状态（1 表示在线，0 表示离线）
     - 活跃用户统计
   - 特点：节省空间，适合处理海量的二进制状态数据
7. **HyperLogLog**
   - 适用场景：
     - 独立访客 (UV) 统计
     - 搜索记录去重计数
     - 各种去重计数场景
   - 特点：占用空间极小（约 12KB），适合超大数据量的基数估算，有一定误差率
8. **Geospatial（地理空间）**
   - 适用场景：
     - 附近的人 / 地点（如外卖配送范围、附近商家）
     - 地理位置距离计算
     - 地理围栏
   - 特点：存储经纬度信息，支持距离计算和范围查询
9. **Stream（流）**
   - 适用场景：
     - 消息队列（支持持久化、消费确认、分组消费）
     - 日志收集
     - 事件溯源
   - 特点：Redis 5.0 新增，专为消息处理设计，支持复杂的消息传递模式

---

## 2、缓存穿透、击穿、雪崩、预热、降级

| 概念         | 核心含义                                                     | 发生原因                                                    | 解决思路                                                     |
| ------------ | ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------------------------------------------ |
| **缓存雪崩** | 大量缓存同时失效，请求全打到数据库，导致数据库压力骤增甚至宕机 | 1. 缓存 key 设置了相同的过期时间 2. Redis 宕机              | 1. 过期时间加随机值避免同时失效 2. 多级缓存（本地缓存 + Redis） 3. Redis 高可用（主从、哨兵、集群） 4. 熔断 / 限流保护数据库 |
| **缓存穿透** | 查询一个不存在的数据，缓存和数据库都没有，每次请求都穿透到数据库 | 1. 恶意攻击查询不存在的 key 2. 业务逻辑允许查询不存在的数据 | 1. 布隆过滤器提前拦截不存在的 key 2. 查询结果为空也缓存（设置较短过期时间） 3. 接口层做参数校验 |
| **缓存击穿** | 一个热点 key 过期瞬间，大量请求同时访问该 key，都打到数据库  | 热点 key 过期，同时有大量并发请求                           | 1. 互斥锁（缓存失效时，一个请求去数据库查，其他请求等待（直到缓存被重建）） 2. 热点 key 永不过期或后台定时更新 3. 热点数据提前预热 |
| **缓存预热** | 系统启动或低峰期提前将热点数据加载到缓存，避免首次访问时缓存缺失 | 1. 系统重启后缓存为空 2. 大促前热点数据未提前加载           | 1. 写脚本批量加载热点数据 2. 订阅数据库 binlog 异步更新缓存 3. 系统启动时主动加载 |
| **缓存降级** | 在缓存或数据库压力过大时，主动降低缓存功能，保证核心业务可用 | 1. Redis 性能下降或不可用 2. 数据库负载过高                 | 1. 返回默认值或旧数据 2. 关闭非核心功能的缓存查询 3. 限流 + 排队机制 |

**解决方法**

| 问题类型     | 核心解决思路                          | 具体实现方法                                                 | 适用场景                                   |
| ------------ | ------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ |
| **缓存雪崩** | 避免缓存同时失效 + 增强系统抗风险能力 | 1. **过期时间随机化**（如基础时间 + 5~10 分钟随机值） 2. **实现多级缓存**（本地缓存 Caffeine + 分布式缓存 Redis） 3. **Redis 集群高可用**（主从复制 + 哨兵模式，至少 3 主 3 从） 4. **数据库限流**（使用 Sentinel 或 Hystrix 限制并发量） 5. **缓存降级开关**（极端情况直接返回兜底数据） | 电商大促、热点活动等流量集中场景           |
| **缓存穿透** | 拦截无效请求 + 缓存空结果             | 1. **布隆过滤器**（预存所有可能存在的 key，拦截不存在的请求） 2. **空值缓存**（查询结果为空时，缓存空值并设置短期过期时间） 3. **接口层校验**（过滤非法参数，如 ID<=0 的请求） 4. **限流防护**（对同一 IP 的高频异常请求进行限流） | 恶意攻击、业务上允许查询不存在数据的场景   |
| **缓存击穿** | 保护热点 key 的缓存有效性             | 1. 互斥锁（Redis 的 SETNX 命令，只有一个线程更新缓存，其他线程等待） 2. 热点 key 永不过期（业务层控制更新，不设置过期时间） 3. 定时任务预热（后台线程提前更新即将过期的热点数据） 4. 分布式锁（Redisson 实现，保证缓存更新的原子性） | 秒杀商品、热门文章等单一热点数据场景       |
| **缓存预热** | 主动加载热点数据到缓存                | 1. 启动加载（系统启动时执行脚本，批量查询热点数据写入缓存） 2. 定时任务（低峰期定时刷新热点数据，如凌晨 3 点执行） 3. 流量触发预热（首次访问时异步加载关联热点数据） 4. 数据库 binlog 同步（通过 Canal 监听 binlog，实时同步更新缓存） | 系统重启后、大促活动前、新功能上线时       |
| **缓存降级** | 牺牲非核心功能保障核心流程            | 1. 静态化降级（返回本地静态文件，如商品详情页静态化） 2. 功能降级（关闭推荐、评价等非核心模块的缓存查询） 3. 数据降级（返回旧版本数据或默认值，如库存显示 “充足”） 4. 限流降级（超出阈值后排队等待，或直接返回降级提示） | Redis 集群故障、数据库压力过高、流量突增时 |



## 3、Redis 主从复制

### 全量复制、增量复制过程

**Redis 主从同步的真实机制**：

1. **全量同步**：
   - 主节点执行 `bgsave`（fork 一个子进程进行数据持久化，） 生成 RDB 文件
   - 将 RDB 文件发送给从节点
   - 从节点清空本地数据，加载 RDB 文件
   - 同时，主节点将 RDB 生成期间的写命令存入**内存缓冲区**（不是日志文件）
   - RDB 发送完成后，主节点再把缓冲区中的命令发送给从节点
2. **增量同步**：
   - 基于**复制偏移量**和**复制积压缓冲区**（内存环形缓冲区）
   - 从节点发送自己的偏移量，主节点只发送从该位置起的增量命令（偏移量如果超出复制积压缓冲区就要重新执行`全量同步`）
   - 不依赖磁盘日志文件，而是直接内存到内存的命令传输

---

Redis 的主从同步是**热更新**的。

在主从复制过程中：

- **主节点**在同步数据给从节点的同时，**依然可以正常处理读写请求**，不会中断服务
- **从节点**在接收和加载 RDB 文件阶段会短暂阻塞（不能处理客户端读请求），但加载完成后会持续从主节点同步增量数据
- 增量同步阶段，从节点可以在**几乎不中断服务**的情况下持续更新数据

简单来说：

- 主节点全程不中断服务（真正热更新）
- 从节点只有在初始全量同步的 RDB 加载阶段会短暂不可读，之后保持热更新状态

### 什么时候全量复制、增量复制

**全量同步之后，正常情况下所有后续同步都是增量同步**。

全量同步只在以下初始情况下发生：

- 从节点第一次连接主节点
- 从节点断线后偏移量不在主节点的复制积压缓冲区范围内

在这些情况之后，主从之间就会进入稳定的增量同步模式：

- 主节点将写命令同步发送给从节点
- 同时维护复制偏移量确保数据一致性
- 只有在网络中断或积压缓冲区溢出时才可能再次触发全量同步

---

### 增量复制的工作方式

Redis 主从增量同步的实际机制是**批量 + 异步**的：

**增量同步的工作方式**：

- 主节点每执行一个写命令，会同时做两件事：
  1. 写入自己的**复制积压缓冲区**（内存环形缓冲区）
  2. 异步地发送给已连接的从节点
- 发送不是单条命令逐个发送，而是**批量打包发送**，减少网络开销
- 网络传输是异步的，主节点不会等待从节点确认就继续处理下一个命令

**影响发送频率的因素**：

- 网络 I/O 缓冲区大小
- 命令执行频率
- 系统的 TCP 传输特性（Nagle 算法等）

**数据一致性保障**：

- 每个命令都有偏移量记录
- 从节点定期向主节点报告自己的偏移量
- 主节点根据偏移量确保从节点最终拿到所有命令

**特殊情况**：

- 如果从节点断线后重连，只要它的偏移量还在主节点的复制积压缓冲区范围内，就只需补传缺失的命令

---

## 4、影响 Redis 性能的因素

## 

1. 影响 Redis 性能的因素有哪些

| 影响维度           | 具体因素                                   | 对性能的影响                                                 |
| ------------------ | ------------------------------------------ | ------------------------------------------------------------ |
| **硬件资源**       | CPU 性能                                   | 单线程核心逻辑依赖 CPU，高并发或复杂命令易导致 CPU 瓶颈      |
|                    | 内存容量与速度                             | 内存不足触发频繁淘汰；启用 swap 会导致性能骤降               |
|                    | 网络带宽                                   | 大 value 传输或高并发会占用带宽，增加延迟                    |
|                    | 磁盘 IO 性能                               | 影响 RDB 写入和 AOF 同步速度（尤其是 `appendfsync always` 模式） |
| **配置参数**       | 持久化策略（RDB/AOF）                      | `bgsave` 的 `fork` 阻塞；AOF 高频同步导致 IO 开销大          |
|                    | 内存淘汰策略（`maxmemory-policy`）         | 不合理策略（如 `noeviction`）导致写入失败；频繁淘汰热点数据增加开销 |
|                    | 连接数限制（`maxclients`）                 | 过小导致拒绝连接；过大占用系统资源（文件描述符、内存）       |
|                    | 过期键清理机制                             | 大量键集中过期触发主线程阻塞                                 |
| **数据结构与命令** | 数据结构选择（如 `LIST`/`HASH`/`SET`）     | 不合适的结构（如用 `LIST` 存储海量数据并执行 `DEL`）会导致阻塞 |
|                    | 命令复杂度（如 `KEYS *`/`SORT`/`HGETALL`） | 高复杂度命令阻塞主线程，影响响应速度                         |
|                    | 键值大小（大 value）                       | 大 value 增加网络传输时间和内存占用，降低处理效率            |
| **集群与部署**     | 主从复制延迟                               | 从节点数据滞后，主从切换可能丢失数据                         |
|                    | 哨兵 / 集群选举与重平衡                    | 频繁切换或重平衡导致服务短暂不可用或性能抖动                 |
|                    | 单节点实例数量                             | 过多实例竞争 CPU、内存、网络资源                             |
| **外部因素**       | 客户端行为（短连接、空闲连接）             | 频繁建联 / 断联增加开销；空闲连接占用资源                    |
|                    | 网络环境（延迟、抖动）                     | 跨机房部署等场景放大命令执行耗时                             |
|                    | 操作系统配置（如 `vm.overcommit_memory`）  | 配置不当可能导致 `fork` 失败或内存管理异常                   |

1. **硬件资源限制**

- **CPU 性能**：
  Redis 是单线程处理命令（核心逻辑），高并发场景下 CPU 可能成为瓶颈（如频繁执行复杂命令 `SORT`、`KEYS *` 等）。多核心 CPU 可通过多实例（而非单实例多线程）提升吞吐量。
- **内存容量与速度**：
  - 内存不足会导致 Redis 触发 **内存淘汰策略**（如 LRU 淘汰），频繁淘汰数据会增加开销。
  - 若启用 swap（内存与磁盘交换），性能会急剧下降（Redis 应禁用 swap）。
- **网络带宽**：
  高并发读写（尤其是大 value 传输）会占用大量带宽，导致网络拥堵，延迟增加。

2. **Redis 配置参数**

- **持久化策略**：
  - `bgsave` 时 `fork` 子进程会短暂阻塞主进程，数据量越大阻塞时间越长。
  - AOF 配置为 `appendfsync always` 会导致每条命令都同步磁盘，IO 开销大；`everysec` 是平衡选择。
- **内存淘汰策略**：
  当内存达到 `maxmemory` 时，若淘汰策略不合理（如 `noeviction` 拒绝写入），或频繁淘汰热点数据，会导致性能波动。
- **连接数限制**：
  `maxclients` 配置过小会拒绝新连接；过多连接会占用系统资源（文件描述符、内存）。
- **过期键清理**：
  大量过期键同时触发清理（如定时任务集中过期），会导致主线程阻塞。

3. **数据结构与命令使用**

- **数据结构选择**：
  - 例如用 `LIST` 存储大量数据并频繁执行 `LPOP/LPUSH` 效率高，但用 `DEL` 删除整个大列表会阻塞主线程。
  - 避免使用 `Hash` 存储海量小键（可采用哈希表分片优化）。
- **命令复杂度**：
  - 高复杂度命令（如 `KEYS *`、`HGETALL` 遍历大集合、`SORT` 排序）会阻塞主线程，应改用 `SCAN` 等增量命令。
  - 频繁执行 `FLUSHDB`/`FLUSHALL` 会清空数据，导致瞬间阻塞。
- **键值大小**：
  存储大 value（如几 MB 的字符串、大列表）会增加网络传输时间和内存占用，建议拆分或压缩。

4. **集群与部署架构**

- **主从复制延迟**：
  主从同步延迟过高时，从节点读取到旧数据，且主节点故障切换可能丢失数据。
- **哨兵 / 集群选举**：
  频繁的主从切换或集群分片重平衡，会导致短暂的服务不可用或性能抖动。
- **实例数量**：
  单台服务器部署过多 Redis 实例，会导致 CPU、内存、网络资源竞争。

5. **外部因素**

- **客户端行为**：
  - 大量空闲连接未及时释放，占用连接数。
  - 客户端频繁建立 / 断开连接（如短连接），增加握手开销。
- **网络环境**：
  客户端与 Redis 服务器之间的网络延迟（如跨机房部署），会放大命令执行耗时。
- **操作系统配置**：
  - 内核参数（如 `vm.overcommit_memory` 未设置为 1，可能导致 `fork` 失败）。
  - 磁盘 IO 性能（影响 AOF 同步和 RDB 写入速度）。

**性能优化思路**

1. 优先选择合适的数据结构和低复杂度命令（参考 Redis 命令复杂度表）。
2. 合理配置持久化策略（如混合持久化、控制 AOF 重写频率）。
3. 避免单实例承载过高压力，通过主从分离、集群分片分担负载。
4. 监控关键指标（内存使用率、CPU 负载、命令响应时间、连接数），及时发现瓶颈。

通过针对性优化这些因素，可显著提升 Redis 的稳定性和性能。
