# 七天八股速记

## 第一天 Java基础知识

### ① 接口和抽象类的区别

**接口**

1. **方法**：接口里全是抽象方法，没有普通方法 。
2. **关键字**：使用 `interface` 关键字定义 。
3. **变量**：只能定义静态常量 。
4. **子类实现**：子类必须实现接口中的所有方法 。而且一个类可以 `implements` 多个接口，实现多继承 。
5. **构造方法**：接口不能有构造方法 。

**抽象类**

1. **方法**：抽象类既可以包含抽象方法，也能有普通方法 。
2. **关键字**：使用 `abstract` 关键字修饰 。
3. **变量**：可以定义成员变量 。
4. **子类实现**：子类需要实现抽象类中的所有抽象方法 。不过 Java 中一个类只能继承一个抽象类，遵循**单继承原则** 。
5. **构造方法**：抽象类可以有构造方法 ，主要用于给子类初始化一些公共资源 。

---

### ① Java中的继承和C++有什么区别

C++中可以实现多继承，Java中只能实现单继承

---

### ① Java 中有哪些数据结构？用过 HashMap 吗，说一下 HashMap 底层实现

- 数据结构有数组、链表、栈、队列、堆、树、Map等
- HashMap在JDK1.7之前采用数组加链表的形式实现，在1.8之后使用了红黑树：通过底层数组存储对象节点，采用链地址法，把新增对象节点连接在当前地址的节点下面，且规定当链表长度大于8时，将链表转换成红黑树结构。

> 介绍下红黑树：
>
> - 红黑树是一种自平衡二叉搜索树，**（Self-Balancing Binary Search Tree, BST）**，通过在节点中引入 “颜色”（红色或黑色）这一属性，并遵循严格的颜色规则，确保树的高度始终维持在 **O(log n)** 级别（n 为节点总数），从而保证插入、删除、查找等核心操作的时间复杂度稳定为 **O(log n)**，避免了普通二叉搜索树在极端情况下（如有序插入）退化为链表、操作复杂度降至 O (n) 的问题。
>
> 二叉搜索树
>
> - 对于任意节点，其左子树中**所有节点的值**都**小于**该节点的值
> - 对于任意节点，其右子树中**所有节点的值**都**大于**该节点的值
> - 左右子树本身也必须是二叉搜索树
> - （通常约定）树中不包含值相等的节点

---

### ① Java中用的是值传递还是引用传递

值传递，无论是基本数据类型还是引用数据类型，都是值传递

---

### ① 面向过程和面向对象有什么区别？

- 面向过程是一种以过程为中心的编程思想，在处理某件事的时候，以正在进行什么为主要目标，分步骤完成目标。

- 而面向对象的思想是将事物抽象为对象，赋予其属性和方法，通过每个对象执行自己的方法来完成目标。

- 面向过程效率更高，而面向对象耦合低（易复用），扩展需求，易维护。

---

### ① final、finally、finalize的区别

1. final 用于修饰属性、类、方法，修饰的变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显示指定初始值。
2. finally 用于异常处理，只能用在 try/catch 中，finally 后的代码总会被执行（当`try`块中有`return`语句时，`finally`块仍然会执行 ）。
3. finalize 是 java.lang.Object 类中的方法，每一个对象都会继承这个方法，再垃圾回收机制（GC）执行的时候会被调用，允许回收未被使用的内存垃圾。

**finally 执行顺序分析（try中有return）**

1. **`try`块中执行`return`语句**：当程序执行到`try`块中的`return`语句时，它首先会将`return`语句要返回的值暂存起来。例如，如果`return`语句返回一个变量的值，它会先获取这个变量当时的值并保存。
2. **执行`finally`块**：在暂存返回值后，程序会去执行`finally`块中的代码。这是因为`finally`块的设计目的就是无论`try`块中是否发生异常，也无论`try`块以何种方式结束（包括`return`语句），都要确保执行其中的代码。
3. **返回暂存的值**：`finally`块执行完毕后，程序会返回之前暂存的值。

---

### ① 什么是序列化？是什么反序列化？

- 序列化其实就是将对象转换为字节序列格式，使其可存储可传输。
- 反序列化就是将字节序列格式转换成对象，是序列化的补集。

---

### ① 什么是不可变类？

不可变类是指实例的属性不能被修改的类。一个不可变类的实例对象从被创建出来，它的成员变量就不能被修改。Java 平台的类库中包含许多的不可变类，比如**String、基本类型的包装类等**。不可变类比一般的更加安全。

----

### ① 为什么 Java中 String 是不可变类？

1. String 类中包含 char 数组 value、整型的 offset 和 count 三个属性，这三个属性都是 private 的，且没有提供方法修改数值，因此在初始化后无法从外部改变。
2. String 类中的这三个属性都是被 final 修饰的，无法从内部进行改变。
3. 方法区有一个特殊存储区域 String Pool，当创建 String 时，如果在 String Pool 中找到相同的字符串值，则会返回一个已存在 String 的引用而不会新建一个对象。假设 String 是可变的，则会导致其他引用这个字符串值的 String 的值发生变化。

---

### ① API 和 SPI 的区别

API 和 SPI 都是制定接口传输数据。

- API 是由实现方负责定义和实现，调用方只负责调用的 API。

- 而 SPI 是指由调用方制定的接口，这个接口由实现方针对接口进行不同的实现，再由调用方选择实现方。

  例如在 JDBC 连接数据库时，针对不同的数据库需要不同的驱动实现， JDBC 提供了驱动接口，由不同的实现方进行实现了这些不同的驱动，然后我们就可以在 JDK 中引用实这些实现了的驱动包进行使用。



---

---

## 第二天 Java并发编程

### ② 线程和进程的区别

**进程**

- 定义：操作系统进行资源分配和调度的基本单位
  - 独立的运行单元，拥有各自独立的内存空间（包括**堆、方法区**等），因此 **进程内的内存资源（如对象、变量等）无法直接共享。**
  - 可以通过其他方法实现间接资源共享，如：
    - **文件系统：**多个进程可以通过读写同一个文件来共享数据。例如，进程 A 将数据写入文件，进程 B 读取该文件获取信息。但需要注意文件锁和并发控制，避免数据不一致。
    - **网络通信：**通过 Socket、HTTP、RPC（如 RMI、Dubbo）等网络协议，进程间可以通过网络传输数据实现共享。这是分布式系统中最常用的方式。
    - **共享内存：**利用操作系统提供的共享内存机制（如 Linux 的`shm`），通过 JNI（Java Native Interface）调用本地方法实现进程间内存共享。这种方式效率高，但实现复杂，且依赖底层系统。
    - **数据库或缓存：**多个进程可以通过访问同一个数据库（如 MySQL）或分布式缓存（如 Redis）共享数据。数据库和缓存本身提供了并发控制机制，适合需要持久化或高可用的场景。
    - **消息队列：**如 ActiveMQ、RabbitMQ 等，进程间通过发送 / 接收消息间接共享数据，适合异步通信场景。
- 从属关系：允许程序的实例
- 资源共享：进程
- 上下文切换：切换速度慢
- 操纵方：操作系统

**线程**

- 定义：操作系统能够进行运算调度的最小单位
- 从属关系：进程的一个执行流
- 资源共享：线程间可以共享资源
- 上下文切换：切换相对速度快
- 操纵方：编程人员

---

### ② 线程和协程的区别？什么场景下用到协程？

1. 线程和协程的区别：

   **线程**

   - 定义：操作系统最小的执行单元
   - 从属关系：一个进程可以有多个线程
   - 同步异步：同步机制
   - 资源消耗：MB级，更大

   **协程**

   - 定义：操作系统最小的资源管理单元
   - 从属关系：一个线程可以有多个协程
   - 同步异步：异步机制
   - 资源消耗：KB级，更小

   > 在一些特定的场景下，**协程**可以提供更高效的并发编程解决方案：
   >
   > - **高并发IO密集型应用**：当应用程序需要同时处理大量IO操作（如网络请求、数据库查询等）时，使用协程可以避免线程切换的开销，提高并发处理能力。
   >
   > - **异步编程**：协程可以使异步代码的编写更加简洁和可读。通过使用协程库或语言提供的异步/await等关键字，可以编写顺序化、可读性高的异步代码，而无需显式地处理回调函数和线程切换。
   >
   > - **有限状态机**：协程可以用于实现有限状态机（FSM）的编程模型。通过使用协程来表示状态和状态转换，可以简化复杂的状态逻辑和事件处理。
   >
   > 需要注意的是，协程并非在所有情况下都是最佳选择。在某些情况下，如CPU密集型任务或需要与底层系统紧密交互的情况下，线程模型可能更为适合。在选择使用协程时，需要根据具体的应用场景和需求进行评估和权衡。
   >

2. 什么场景下用到协程

   - **高并发服务**，如秒杀系统、RPC 服务器等。
   - **爬虫开发**
   - **即时通信服务**，如聊天室、游戏服务器等。

---

### ② 怎么理解容器的线程安全与线程不安全？里面具体做了什么样的实现？

1. **线程安全**

   在拥有共享数据的多条线程并行执行的程序中，代码可以通过**同步机制**保证各个线程都可以正常且正确的执行，不会出现数据错误等意外情况，成为线程安全。

2. **线程不安全**

   不提供机制保护，出现多个线程先后更改数据造成得到**脏数据**的可能。

3. **线程安全里面具体做了什么样的实现**

   - **互斥同步**

     通过 `synchronized`关键字编译后，在同步块的前后生产 `monitorenter`和`monitorexit`两个字节码指令，需要明确的 `reference`对象进行解锁。获取 `reference`对象后当前线程可以操作代码块，当锁的持有数归 0 锁释放后，可以再被其他线程获取。

   - **非阻塞同步**

     对互斥同步的优化，对于获取锁失败的线程，将不再让其挂起，而是自旋等待一段时间，若还剩无法获取锁才将其挂起。

     - **无同步方案**

       - **可重入代码**

         不允许任何进程进行修改，在运行的任何时刻中断去执行其他代码，在合理范围内（多次重入等）继续执行。

       - **线程本地储存**

         每个线程都有一个副本，对线程所做的修改都是对副本修改，不会对其他副本造成影响。

---

### ② Java 如何实现线程安全

1. 使用 `Atomic` 类，通过 CAS 保证操作不会在执行过程中被中断

   - 使用 AtomicInteger 和 AtomicReference 等原子类：
     Java 中提供了一系列原子类，可以实现针对基本数据类型和对象引用的原子操作，避免了线程安全问题。

     ```java
     private AtomicInteger count = new AtomicInteger(0);
     
     public void increment() {
         count.incrementAndGet();
     }
     ```

     

2. 使用 `synchronized`进行加锁，`volatile`关键字用于修饰变量，确保多个线程对该变量的读写操作具有**可见性**。即，一个线程对变量的修改能立即被其他线程看到。

   需要对集合容器内部的方法进行加锁，以 map 为例，由于 hashMap 内部没有锁，所以它会导致线程不安全，而如果我们使用 hashTable，由于其中使用 `synchronized` 关键字进行了加锁，就可以保证线程安全。

   ```java
   public synchronized void synchronizedMethod() {
       // 线程安全的代码块
   }
   ```

3. 使用 `TLS`（ **Thread-Local Storage（线程本地存储）**） 避免资源竞争，提供线程的副本进行同时访问和维护。

   ThreadLocal 可以实现每个线程都拥有自己的**变量副本**，从而避免多个线程之间的数据共享问题。

   ```java
   private ThreadLocal<Integer> threadLocal = ThreadLocal.withInitial(() -> 0);
   
   public void increment() {
       int value = threadLocal.get();
       threadLocal.set(value + 1);
   }
   ```

----

### ② 并发类库提供的线程池实现有哪些？

1. `newCachedThreadPool()`

**特点**：

- **动态线程数量**：核心线程数为 0，最大线程数为`Integer.MAX_VALUE`（理论上无上限）。
- **自动回收空闲线程**：线程空闲超过 60 秒会被终止并移除。
- **任务队列**：使用`SynchronousQueue`（同步队列），不存储任务，直接提交给线程执行。
- **适用场景**：短期、轻量级任务（如临时的网络请求），任务执行时间短，且任务数量波动大。

**示例**：

```java
ExecutorService cachedPool = Executors.newCachedThreadPool();
```

2. `newFixedThreadPool(int nThreads)`

**特点**：

- **固定线程数量**：核心线程数和最大线程数均为`nThreads`，线程不会被回收（除非线程池关闭）。
- **任务队列**：使用`LinkedBlockingQueue`（无界队列），当所有线程忙碌时，新任务会排队等待。
- **适用场景**：任务数量稳定、执行时间较长的场景（如服务器后台任务），避免频繁创建 / 销毁线程的开销。

**注意**：若任务队列无限增长，可能导致 OOM（内存溢出）。

**示例**：

```java
ExecutorService fixedPool = Executors.newFixedThreadPool(5); // 固定5个线程
```

3. `newSingleThreadExecutor()`

**特点**：

- **单线程执行**：核心线程数和最大线程数均为 1，所有任务按顺序执行。
- **任务队列**：使用`LinkedBlockingQueue`（无界队列），保证任务串行化处理。
- **线程自动恢复**：若唯一的线程因异常终止，会自动创建新线程替代。
- **适用场景**：需要保证任务顺序执行的场景（如日志写入、单线程事务处理），避免并发冲突。

**示例**：

```java
ExecutorService singlePool = Executors.newSingleThreadExecutor();
```

4. `newSingleThreadScheduledExecutor()`

**特点**：

- **单线程定时任务**：基于单线程实现，支持定时或周期性执行任务。
- **核心方法**：`schedule()`（延迟执行一次）、`scheduleAtFixedRate()`（固定频率执行）等。
- **适用场景**：单线程环境下的定时任务（如定期备份、心跳检测）。

**示例**：

```java
ScheduledExecutorService singleScheduledPool = Executors.newSingleThreadScheduledExecutor();
// 延迟1秒后执行任务
singleScheduledPool.schedule(() -> System.out.println("任务执行"), 1, TimeUnit.SECONDS);
```

5. `newScheduledThreadPool(int corePoolSize)`

**特点**：

- **多线程定时任务**：核心线程数为`corePoolSize`，支持定时或周期性执行任务。
- **任务队列**：使用`DelayedWorkQueue`（延迟队列），按任务的执行时间排序。
- **适用场景**：需要多个线程处理定时任务的场景（如多任务定时调度），避免单线程瓶颈。

**示例**：

```java
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(3);
// 延迟2秒后，每3秒执行一次任务
scheduledPool.scheduleAtFixedRate(() -> System.out.println("周期性任务"), 2, 3, TimeUnit.SECONDS);
```

6. `newWorkStealingPool(int parallelism)`

**特点**：

- **工作窃取机制**：基于`ForkJoinPool`实现，线程可 “窃取” 其他线程的任务执行，提高 CPU 利用率。
- **并行度**：`parallelism`指定并行线程数（默认等于 CPU 核心数），无最大线程数限制。
- **任务队列**：每个线程有独立的双端队列，空闲线程从其他队列尾部窃取任务。
- **适用场景**：CPU 密集型任务（如大规模计算），充分利用多核处理器性能。

**示例**：

```java
ExecutorService workStealingPool = Executors.newWorkStealingPool(4); // 并行度为4
```

**总结对比**

| 线程池方法                           | 核心线程数 | 最大线程数          | 队列类型              | 核心特点           | 适用场景         |
| ------------------------------------ | ---------- | ------------------- | --------------------- | ------------------ | ---------------- |
| `newCachedThreadPool()`              | 0          | `Integer.MAX_VALUE` | `SynchronousQueue`    | 动态伸缩，短期任务 | 轻量、短期任务   |
| `newFixedThreadPool(n)`              | n          | n                   | `LinkedBlockingQueue` | 固定线程，任务排队 | 稳定、长期任务   |
| `newSingleThreadExecutor()`          | 1          | 1                   | `LinkedBlockingQueue` | 单线程串行执行     | 需顺序执行的任务 |
| `newSingleThreadScheduledExecutor()` | 1          | 1                   | `DelayedWorkQueue`    | 单线程定时任务     | 单线程定时调度   |
| `newScheduledThreadPool(n)`          | n          | `Integer.MAX_VALUE` | `DelayedWorkQueue`    | 多线程定时任务     | 多任务定时调度   |
| `newWorkStealingPool(n)`             | n          | 无限制              | 双端队列（每个线程）  | 工作窃取，多核高效 | CPU 密集型计算   |

实际开发中，需根据任务特性（执行时间、数量、是否定时等）选择合适的线程池，或通过`ThreadPoolExecutor`自定义线程池参数以满足更精细的需求。

---

### ② 线程池中的几个参数，比如核心线程数、最大线程数、如果让你定，你会怎么样去设定这些值？

一般多线程执行的任务类型可以分为 **CPU密集型**和**I/O密集型**，根据不同的任务类型，我们计算线程数的方法也不一样。

假设 N 为CPU核心数，WT 为线程等待时间，ST 为线程时间运行时间

- **CPU 密集型任务：**主要消耗CPU资源，可以额外设置一个线程，一旦任务暂停，CPU就会处于空闲状态，额外的线程可以充分利用 CPU 的空闲时间，**线程数为 N + 1**

- **I/O 密集型任务：**I/O 交互的处理消耗较大，而线程在处理 I/O 的时候不会占用 CPU 来处理，因此可以多配置一些线程，**线程数 2*N**

- 在一般的业务应用场景中，我们可以用下列公式计算线程数：

  **线程数 = N * （1 + WT / ST）**

可以根据实际业务场景，从  “N+1” 和 “2N” 中选出一个适合的，计算出一个大概的线程数，之后通过实际压测进行增大或减小线程数调整，然后观察具体的运行时间变化，最终确定一个具体的线程数。

---

### ② Java 中有哪些锁

![image-20250909180055005](https://typora-yuanbaoer2.oss-cn-shanghai.aliyuncs.com/img-typora/image-20250909180055005.png)

---

### ② 怎么理解乐观锁和悲观锁？

**乐观锁：**在操作数据时非常的乐观，**认为别人不会修改数据**，因此不加锁，在执行数据更新时采用比较判断的方式进行操作，如果当前数据被修改过，则放弃操作，否则就执行操作。**乐观锁默认不会上锁**

典型的乐观锁包括 **CAS 机制**和**版本号机制**

- **CAS 机制（Compare And Swap，比较并交换）**操作过程包括 compare 和 set，通过内存位置、预期值和拟写入的新值三个数据，先去比较待修改对象是否为它自身所持有的对象，然后比较该对象的数据是否等于预期数据，如果都为是，那就将该对象数据修改为新的数据。

  > CAS（Compare And Swap，比较并交换）是一种**无锁同步机制**，用于多线程环境下实现变量的原子操作，避免了使用锁（如`synchronized`）带来的性能开销和线程阻塞问题。它是并发编程中的核心技术，Java 中的`java.util.concurrent.atomic`包（如`AtomicInteger`）就是基于 CAS 实现的。
  >
  > ### **CAS 的核心原理**
  >
  > CAS 操作涉及三个关键值：
  >
  > 1. **内存地址 V**：存储要修改的变量的内存位置。
  > 2. **预期值 A**：线程认为变量当前应该的值。
  > 3. **新值 B**：线程想要将变量修改为的值。
  >
  > **执行逻辑**：
  > 当且仅当内存地址 V 中的值等于预期值 A 时，才将 V 的值更新为新值 B；否则不做任何操作。整个过程是**原子操作**（由 CPU 指令保证，不可中断）。
  >
  > 可以简单理解为以下伪代码：
  >
  > ```java
  > boolean cas(V, A, B) {
  >     if (V的值 == A) {
  >         V的值 = B;
  >         return true; // 修改成功
  >     } else {
  >         return false; // 修改失败
  >     }
  > }
  > ```
  >
  > ### **CAS 的优势：无锁编程**
  >
  > 与`synchronized`等锁机制相比，CAS 的核心优势是**非阻塞**：
  >
  > - 当多个线程竞争时，失败的线程不会被挂起（阻塞），而是可以选择重试或放弃，减少了线程上下文切换的开销。
  > - 适用于**读多写少**的场景，性能优于锁机制。
  >
  > ### **Java 中的 CAS 应用：`AtomicInteger`**
  >
  > Java 通过`sun.misc.Unsafe`类直接调用 CPU 的 CAS 指令实现原子操作。以`AtomicInteger`的`incrementAndGet()`（自增 1）为例：
  >
  > ```java
  > public class AtomicInteger extends Number implements java.io.Serializable {
  >     private volatile int value; // 共享变量，volatile保证可见性
  > 
  >     public final int incrementAndGet() {
  >         return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
  >     }
  > }
  > 
  > // Unsafe类中的核心实现（简化）
  > public final int getAndAddInt(Object o, long offset, int delta) {
  >     int expected;
  >     do {
  >         expected = this.getIntVolatile(o, offset); // 读取当前值（预期值A）
  >     } while (!this.compareAndSwapInt(o, offset, expected, expected + delta)); 
  >     // 循环重试：若CAS失败（预期值与实际值不符），重新读取预期值并再次尝试
  >     return expected;
  > }
  > ```
  >
  > **执行流程**：
  >
  > 1. 线程读取当前值作为预期值 A。
  > 2. 调用`compareAndSwapInt`执行 CAS 操作，尝试将值更新为 A+1。
  > 3. 若成功，返回新值；若失败（其他线程已修改值），重新读取预期值并重试（**自旋**），直到成功。
  >
  > ### **CAS 的问题与局限性**
  >
  > 1. **ABA 问题**
  >    - 场景：线程 1 读取值为 A，线程 2 将 A 改为 B，再改回 A。线程 1 的 CAS 操作会认为值未变而成功，但实际发生了中间修改。
  >    - 解决：使用 “版本号” 机制（如`AtomicStampedReference`），每次修改时更新版本号，CAS 时同时检查值和版本号。
  > 2. **自旋开销**
  >    - 若并发激烈，CAS 可能多次失败并持续自旋，占用 CPU 资源（类似于 “忙等”）。
  >    - 优化：JDK 中的一些实现会限制自旋次数（如`Synchronized`的锁升级机制）。
  > 3. **只能保证单个变量的原子操作**
  >    - CAS 仅支持对单个变量的原子修改，无法直接实现多个变量的原子操作（需用锁或组合对象）。
  >
  > ### **总结**
  >
  > CAS 是一种高效的无锁同步机制，通过 “比较 - 交换” 的原子操作保证变量修改的线程安全，避免了锁的阻塞开销。它是 Java 并发工具类（如`Atomic*`、`ConcurrentHashMap`）的核心实现原理，适用于并发量不极端、读多写少的场景。但需注意 ABA 问题、自旋开销等局限性，根据实际场景选择合适的同步方案。

- **版本号机制：**在表中增加一个 version 字段，每更新一次数据就将此值+1。当读取数据时，连同version字段一起读取。当提交更新时，会将数据库表中对应记录的当前版本号与之前取出来的版本号比较，如果一致则执行更新，如果不一致则表示是过期数据放弃操作。

**悲观锁：**在操作数据时非常悲观，**总是认为别人会修改数据**，因此需要加锁，在更新数据时直到操作执行完毕才释放资源。**悲观锁默认直接上锁。**

典型的悲观锁实现方式为：`synchronized`关键字、`ReentrantLock`独立锁和 MySQL中的排他锁

- `synchronized`关键字在多线程访问共享数据时同一时刻只能由单个线程抢到资源去执行。且在线程切换时，涉及到操作系统内核态和用户态的切换，这些操作会消耗额外的资源，**因此效率较低。**

---

### ② 怎么理解自旋锁？为什么还会有自旋锁？

- **自旋锁：**线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说负担较大，会给系统的并发性能带来很大的压力。 且对象锁的锁状态的持续时间很短，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的，因此引入了自旋锁。

  - 自旋锁让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。
    为了达成这个等待，自旋锁会执行一段无意义的循环，这个过程称为自旋。
    自旋等待不能替代阻塞，虽然自旋可以避免线程切换带来的开销，但是却占用了处理器的时间。 如果持有锁的线程很快就释放了锁，那么自旋的价值就非常高。否则，自旋的线程就会白白占用处理的资源，不会做任何有意义的工作，反而浪费了性能。 因此，自旋必须要有一个限度，如果自旋超过了设定的时长仍然没有获取到锁，则需要被挂起。

    自旋锁在 JDK 1.4.2 中引入，默认关闭，可以使用 -XX:+UseSpinning 开启，在 JDK1.6 中改为默认开启。同时自旋的默认次数为 10 次，可以通过修改参数 -XX:PreBlockSpin 来调整。
    但是通过调整 -XX:preBlockSpin 来调整自旋次数，会导致很多意外情况。比如刚退出线程锁就被释放。因此 JDK1.6 引入了自适应的自旋锁。

  > 自旋锁（Spin Lock）是一种**非阻塞同步机制**，其核心思想是：当线程尝试获取锁失败时，不会立即阻塞（放弃 CPU 资源），而是通过**循环不断尝试获取锁**（“自旋”），直到成功获取或达到一定次数后再阻塞。
  >
  > ### **为什么需要自旋锁？**
  >
  > 自旋锁的设计源于对**短期锁竞争场景**的优化。传统的互斥锁（如`synchronized`）在获取锁失败时，会将线程切换到阻塞状态（进入内核态等待），这涉及**线程上下文切换**（保存 / 恢复线程状态）和**内核态与用户态切换**，开销较大（通常是微秒级）。
  >
  > 而在以下场景中，锁被占用的时间极短（如纳秒级）：
  >
  > - 锁保护的临界区代码执行时间很短（如简单的变量修改）。
  > - 并发冲突概率低，线程等待锁的时间远小于上下文切换的时间。
  >
  > 此时，让线程 “自旋等待”（循环尝试获取锁）比 “阻塞等待” 更高效 —— 省去了上下文切换的开销，提升整体性能。
  >
  > ### **自旋锁的工作原理**
  >
  > 1. 线程 A 获取锁成功，执行临界区代码。
  > 2. 线程 B 尝试获取锁，发现锁已被占用，进入自旋状态（循环检查锁是否释放）。
  > 3. 线程 A 释放锁后，线程 B 在自旋过程中检测到锁可用，立即获取锁并执行。
  >
  > 伪代码示意：
  >
  > ```java
  > public class SpinLock {
  >     private AtomicReference<Thread> owner = new AtomicReference<>();
  > 
  >     // 获取锁：自旋直到成功
  >     public void lock() {
  >         Thread current = Thread.currentThread();
  >         // 循环尝试CAS操作，直到成功获取锁
  >         while (!owner.compareAndSet(null, current)) {
  >             // 空循环（自旋），不断重试
  >         }
  >     }
  > 
  >     // 释放锁
  >     public void unlock() {
  >         Thread current = Thread.currentThread();
  >         // 只有持有锁的线程才能释放
  >         owner.compareAndSet(current, null);
  >     }
  > }
  > ```
  >
  > - 核心依赖 CAS 操作：通过`AtomicReference`的`compareAndSet`实现锁的获取与释放，保证原子性。
  > - 自旋过程中，线程始终处于**运行状态**（不放弃 CPU），持续占用处理器资源。
  >
  > ### **自旋锁的适用场景与局限性**
  >
  > #### **适用场景**：
  >
  > 1. **短期锁持有**：临界区代码执行时间极短（如几纳秒），自旋等待时间远小于上下文切换时间。
  > 2. **低并发冲突**：锁竞争不激烈，线程自旋几次就能获取到锁。
  > 3. **多核处理器**：自旋时不会阻塞其他线程（其他核可正常工作），适合多核环境。
  >
  > #### **局限性**：
  >
  > 1. **CPU 资源浪费**：若锁被长期占用（如毫秒级），自旋线程会持续消耗 CPU 资源（“空转”），导致系统性能下降。
  > 2. **不公平性**：自旋锁无法保证等待线程的获取顺序，可能导致某些线程长期自旋（“饥饿”）。
  > 3. **不适合单核处理器**：单核 CPU 上，自旋线程会占用全部 CPU 时间，导致持有锁的线程无法执行，形成死锁。
  >
  > ### **Java 中的自旋锁应用**
  >
  > Java 并未直接提供自旋锁 API，但许多并发组件内部使用了自旋优化：
  >
  > - **`synchronized`锁**：JDK 6 及以上对`synchronized`进行了优化，引入 “偏向锁→轻量级锁→重量级锁” 的升级机制，其中**轻量级锁阶段会使用自旋**（默认 10 次），避免直接升级为重量级锁（阻塞）。
  > - **`ReentrantLock`**：基于 AQS（AbstractQueuedSynchronizer）实现，默认使用 “非公平锁”，获取锁失败时会先自旋尝试，再进入等待队列。
  >
  > ### **总结**
  >
  > 自旋锁是对 “短期锁竞争” 场景的针对性优化，通过 “忙等” 避免线程阻塞的上下文切换开销，提升高并发下的性能。但它的适用范围有限，仅适合锁持有时间短、冲突少的场景，否则会因 CPU 空转而降低效率。
  >
  > 简单来说：**自旋锁用 “时间换空间”（CPU 资源换上下文切换开销），是对传统阻塞锁的有效补充**。

- **适应自旋锁**

  自适应自旋锁的自旋的次数不再是固定的，它由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

  线程如果自旋成功了，那么下次自旋的次数会更多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。


---

### ② 间隙锁是什么

间隙是对于键值在条件范围内但并不存在的记录。

间隙锁是指在索引数据时，使用的是范围条件而不是相等条件，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项进行加锁。

间隙锁是开区间，间隙锁 + 行锁合称 next-key lock，每个 next-key lock 是左开右闭区间。间隙锁和 next-key lock 的引入可以解决幻读问题。

> 间隙锁（Gap Lock）是 MySQL 中 InnoDB 存储引擎在**Repeatable Read（可重复读）隔离级别**下，为解决**幻读问题**而引入的一种行级锁。它锁定的不是具体的记录，而是**索引记录之间的间隙**，防止其他事务在该间隙中插入新数据，从而保证事务的隔离性和数据一致性。
>
> ### **核心作用：阻止间隙插入，解决幻读**
>
> 幻读是指一个事务在两次查询中，由于其他事务插入了新数据，导致后一次查询出现了前一次查询没有的 “新记录”。例如：
>
> 1. 事务 A 查询`id > 10`的记录（假设当前只有`id=11`的记录）。
> 2. 事务 B 插入`id=12`的新记录并提交。
> 3. 事务 A 再次查询`id > 10`，会出现`id=12`的新记录，即 “幻读”。
>
> 间隙锁通过锁定`id=11`之后的间隙，阻止事务 B 插入`id=12`的记录，从而避免幻读。
>
> ### **间隙的定义**
>
> 间隙是指索引中**两个连续记录之间的区间**，或**第一条记录之前的区间**、**最后一条记录之后的区间**。例如，对于索引值为`(5, 10, 15)`的表，存在以下间隙：
>
> - `(-∞, 5)`：小于 5 的区间
> - `(5, 10)`：5 到 10 之间的区间
> - `(10, 15)`：10 到 15 之间的区间
> - `(15, +∞)`：大于 15 的区间
>
> ### **间隙锁的触发场景**
>
> 当 InnoDB 在**可重复读隔离级别**下，使用**范围查询**或**等值查询未命中记录**时，会自动加间隙锁。例如：
>
> ```sql
> -- 表结构：id为主键，存在记录id=10、20
> CREATE TABLE test (id INT PRIMARY KEY, name VARCHAR(10));
> INSERT INTO test VALUES (10, 'a'), (20, 'b');
> ```
>
> 1. **范围查询**：
>
>    ```sql
>    -- 事务A执行：查询id在10到20之间的记录
>    SELECT * FROM test WHERE id BETWEEN 10 AND 20 FOR UPDATE;
>    ```
>
>    - 此时会锁定`id=10`和`id=20`的记录（行锁），同时锁定`(10, 20)`的间隙（间隙锁）。
>    - 其他事务无法在`(10, 20)`中间插入`id=15`的新记录。
>
> 2. **等值查询未命中**：
>
>    ```sql
>    -- 事务A查询id=15的记录（不存在）
>    SELECT * FROM test WHERE id = 15 FOR UPDATE;
>    ```
>
>    - 虽然没有匹配的记录，但会锁定`(10, 20)`的间隙，阻止其他事务插入`id=15`的记录。
>
> ### **特点与注意事项**
>
> 1. **仅在可重复读隔离级别生效**：其他隔离级别（如 Read Committed）不会使用间隙锁（MySQL 默认在 Read Committed 下关闭间隙锁）。
> 2. **不阻塞读操作**：间隙锁仅阻止插入、更新、删除等写操作，不影响其他事务的读操作。
> 3. **可能导致死锁**：多个事务锁定重叠间隙时，可能因互相等待对方释放锁而产生死锁。例如：
>    - 事务 A 锁定`(5, 10)`间隙。
>    - 事务 B 锁定`(8, 15)`间隙。
>    - 两者都尝试插入`id=9`的记录，会因互相等待对方释放重叠的`(8, 10)`间隙而死锁。
> 4. **与行锁结合形成 next-key 锁**：InnoDB 中，行锁 + 间隙锁的组合称为`next-key锁`，它既锁定记录本身，也锁定记录前面的间隙（例如`id=10`的 next-key 锁会锁定`(5, 10]`区间）。
>
> ### **总结**
>
> 间隙锁是 InnoDB 在可重复读隔离级别下解决幻读的核心机制，通过锁定索引间隙防止新数据插入。它保证了事务隔离性，但也可能因锁范围扩大导致性能下降或死锁，实际使用中需根据业务场景合理设计索引和查询语句。